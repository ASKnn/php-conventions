Цель данных рекомендаций - снижение сложности восприятия кода, написанного разными авторами;
она достигается путём рассмотрения серии правил и ожиданий относительно написания PHP-кода.

Слова «НЕОБХОДИМО» / «ДОЛЖНО» («MUST»), «НЕДОПУСТИМО» («MUST NOT»), «ТРЕБУЕТСЯ» («REQUIRED»), «НУЖНО» («SHALL»),
«НЕ ПОЗВОЛЯЕТСЯ» («SHALL NOT»), «СЛЕДУЕТ» («SHOULD»), «НЕ СЛЕДУЕТ» («SHOULD NOT»), «РЕКОМЕНДУЕТСЯ» («RECOMMENDED»),
«МОЖЕТ» / «ВОЗМОЖНО» («MAY») и «НЕОБЯЗАТЕЛЬНО» («OPTIONAL») в этом документе следует понимать так,
как это описано в [RFC 2119](https://www.ietf.org/rfc/rfc2119.txt) (и его [переводе](http://rfc.com.ru/rfc2119.htm)).

## 1. Оформление

### 1.1. Базовый стандарт оформления кода
         
Код ДОЛЖЕН быть оформлен согласно всем правилам, указанным в стандарте [PSR-12](https://www.php-fig.org/psr/psr-12/).

### 1.2. Строки

Жесткое ограничение строки ДОЛЖНО составлять 120 символов.
В случае превышения этого ограничения автоматические системы проверки стиля ДОЛЖНЫ считать это ошибочной ситуацией,
для таких ситуаций НЕОБХОДИМО явно отключать проверку стиля с помощью аннотаций:

* `// @codingStandardsIgnoreStart`
* `// @codingStandardsIgnoreStop`

> Это требование дополняет [PSR-12 2.3. Lines](https://www.php-fig.org/psr/psr-12/#23-lines).
>
> Пример:
> 
> ```php
> // @codingStandardsIgnoreStart
> use VendorWithVerlyLongName\ProjectrWithVerlyLongName\ServicesWithVerlyLongName\ServiceFolderWithVerlyLongName\ClassWithVerlyLongName;
> // @codingStandardsIgnoreStop
> ```

### 1.3. Выравнивание присвоений переменных и элементов массива

Блок присвоений ДОЛЖЕН быть выровнен по самому длинному присвоению в блоке.
Если операция присвоения превышает максимальную длину строки НЕОБХОДИМО:

 * или начать новый блок с помощью пустой строки;
 * или выражение должно быть перенесено на новую строку с отступом в 4 пробела,
   при этом оператор присвоения ДОЛЖЕН остаться на той же строке, что и переменная.

> Пример:
> 
> ```php
> // Правильно
> $varName      = 'varName';
> $variableName = 'variableName';
> ```
>
> ```php
> // Не правильно
> $varName = 'varName';
> $variableName = 'variableName';
> ```
> 
> ```php
> // Правильно
> $varName                            = 'varName';
> $secondVariableWithVeryLongNameHere =
>     '123456790123456790123456790123456790123456790123456790123456790123456790123456790';
> ```
>
> ```php
> // Не правильно
> $varName                            = 'varName';
> $secondVariableWithVeryLongNameHere
>     = '123456790123456790123456790123456790123456790123456790123456790123456790123456790';
> ```
> 
> ```php
> // Правильно
> $firstVariableWithVeryLongNameHere = 'varName';
>
> $variableName = '123456790123456790123456790123456790123456790123456790123456790123456790123456790';
> ```
>
> ```php
> // Правильно
> [
>     'elementName'     => 'elementName',
>     'longNameElement' => 'longNameElement',
> ]
> ```
>
> ```php
> // Не правильно
> [
>     'elementName' => 'elementName',
>     'longNameElement' => 'longNameElement',
> ]
> ```
> 
> ```php
> // Правильно
> [
>     'elementName'                       => 'elementName',
>     'secondElementWithVeryLongNameHere' =>
>         '123456790123456790123456790123456790123456790123456790123456790123456790123456790',
> ]
> ```
>
> ```php
> // Не правильно
> [
>     'elementName'                       => 'elementName',
>     'secondElementWithVeryLongNameHere'
>         => '123456790123456790123456790123456790123456790123456790123456790123456790123456790',
> ]
> ```
> 
> ```php
> // Правильно
> [
>     'firstElementWithVeryLongNameHere' => 'elementName',
>
>     'elementName' => '123456790123456790123456790123456790123456790123456790123456790123456790123456790',
> ```

### 1.4. Массивы

При объявлении многострочного массива в конце последнего объявления ДОЛЖНА ставиться запятая,
для однострочного массива - запятую ставить НЕДОПУСТИМО.

> Пример:
>
> ```php
> // Правильно
> [
>     'firstElement'  => 'firstElement',
>     'secondElement' => 'secondElement',
> ]
> ```
>
> ```php
> // Не правильно
> [
>     'firstElement'  => 'firstElement',
>     'secondElement' => 'secondElement'
> ]
> ```
>
> ```php
> // Правильно
> ['firstElement'  => 'firstElement', 'secondElement' => 'secondElement']
> ```
>
> ```php
> // Не правильно
> ['firstElement'  => 'firstElement', 'secondElement' => 'secondElement',]
> ```
> 

### 1.5. Последовательность вызовов (Chaining)

Каждый элемент вызова для последовательностей, состоящих из трех и более элементов ДОЛЖЕН находиться на новой строке.
В случае превышения максимальной длины строки - каждый элемент последовательности вызовов
ДОЛЖЕН находиться на новой строке.

> Пример:
>
> ```php
> // Правильно
> $this->firstMethod();
> ```
>
> ```php
> // Не правильно
> $this
>     ->firstMethod();
> ```
>
> ```php
> // Правильно
> $this
>     ->firstMethod()
>     ->secondMethod()
>     ->thirdMethod();
> ```
>
> ```php
> // Не правильно
> $this->firstMethod()
>     ->secondMethod()->thirdMethod();
> ```
>
> ```php
> // Правильно
> $this
>     ->firstMethod()
>     ->thirdMethod(
>         $firstArgument,
>         $secondArgument,
>         $thirdArgument,
>         $fourthArgument,
>         $fifthArgument,
>         $sixArgument
>     );
> ```
>
> ```php
> // Не правильно
> $this->firstMethod()->thirdMethod(
>     $firstArgument,
>     $secondArgument,
>     $thirdArgument,
>     $fourthArgument,
>     $fifthArgument,
>     $sixArgument
> );
> ```
> 

### 1.6. Выделение управляющих инструкций

Управляющие инструкции: `if`, `for`, `foreach`, `while`, `do-while`, `switch`, `break`, `continue`, `return`
ДОЛЖНЫ отделяться от кода того же уровня вложенности одной пустой строкой.

> Пример:
>
> ```php
> // Правильно
> $count = 5;
> 
> if ($count === 5) {
> // ...
> }
>
> // ...
> ```
>
> ```php
> // Не правильно
> $count = 5; // Отсутствует перевод строки
> if ($count === 5) {
> // ...
> }
> $length = 12; // Отсутствует перевод строки
> // ...
> ```
>
> ```php
> // Правильно
> {
>     if ($count === 5) {
>     // ...
>     }
> }
> ```
>
> ```php
> // Не правильно
> {
> 
>     // Лишняя пустая строка
>     if ($count === 5) {
>     // ...
>     }
>     // Лишняя пустая строка
> }
> ```

## 2. Документирование

### 2.1. Базовый стандарт для оформления документации в коде

Код ДОЛЖЕН быть оформлен согласно всем правилам, указанным в стандарте [PSR-5](https://www.php-fig.org/psr/psr-5/).

### 2.2. Дублирование типов в docblock

Указание типов аргументов с помощью `@param` и `@return`, дублирующее сигнатуру метода НЕДОПУСТИМО.

> Пример:
>
> ```php
> // Правильно
> public function incrementProductPriceByName(string $productName, float $price): bool
> {
> // ...
> ```
>
> ```php
> // Не правильно
> /**
>  * @param string $productName
>  * @param float  $price
>  * @return bool
>  */
> public function incrementProductPriceByName(string $productName, float $price): bool
> {
> // ...
> ```

### 2.3. Массивы в docblock

Типы элементов массивов СТОИТ уточнять в docblock.

> Пример:
>
> ```php
> // Правильно
> /**
>  * @param string[] $productNames
>  */
> public function incrementProductPricesByNames(array $productNames, float $price): bool
> {
> // ...
> ```
>
> ```php
> // Не правильно
> /**
>  * @param array $productNames
>  */
> public function incrementProductPricesByNames(array $productNames, float $price): bool
> {
> // ...
> ```

### 2.4. Неопределенные типы аргументов и возвращаемых результатов

В случае, если аргумент (или возвращаемый результат) метода может быть разных типов
НЕОБХОДИМО перечислить все допустимые типы в docblock.

> Пример:
>
> ```php
> // Правильно
> /**
>  * @param string|int $stringOrIntArgument
>  * @return float|string|object
>  */
> public function mixedMethod($stringOrIntArgument)
> {
> // ...
> ```
>
> ```php
> // Не правильно
> /**
>  * @param mixed $stringOrIntArgument
>  * @return mixed
>  */
> public function mixedMethod($stringOrIntArgument)
> {
> // ...
> ```

### 2.5. Тип переменных

Если ожидаемый тип переменной явно не определен НЕОБХОДИМО определить его с помощью docblock комментария.
Так же необходимо указывать ожидаемый тип, если IDE не может его определить, или определяет не корректно.

> Пример:
> 
> ```php
> $rows = [
>     [
>         'id'        => 1,
>         'createdAt' => new \DateTimeImmutable(),
>     ],
>     [
>         'id'        => 2,
>         'createdAt' => new \DateTimeImmutable(),
>     ],
>     // ...
> ];
> 
> foreach ($rows as $row) {
>     /** @var int $id */
>     $id = $row['id'];
>     /** @var \DateTimeImmutable $createdAt */
>     $createdAt = $row['createdAt'];
>     // ...
> }
> ```

### 2.6. Свойства

Свойства класса ДОЛЖНЫ содержать однострочный docblock, определяющий все возможные типы значений, допустимые в нем.

> Пример:
> 
> ```php
> /** @var string[]|null */
> private $names;
>
> /** @var int|null */
> private $count;
> ```

## 3. Объявление констант, свойств и методов

### 3.1. Последовательность объявлений констант, свойств и методов

В классе ДОЛЖНА соблюдаться последовательность объявлений элементов согласно следующему списку:

1. Публичные константы.
2. Защищенные константы.
3. Приватные константы.
4. Публичные свойства.
5. Защищенные свойства.
6. Приватные свойства.
7. __construct.
8. __destruct.
9. __clone.
10. __invoke.
11. __toString.
12. Публичные методы.
13. Защищенные методы.
14. Приватные методы.

### 3.2. Именование свойств

Названия свойств ДОЛЖНЫ описывать предназначение данных, которые они хранят.

> Пример:
>
> ```php
> // Правильно
> /** @var string[] */
> private $userNames;
> ```
>
> ```php
> // Не правильно
> /** @var string[] */
> private $data;
> ```

### 3.3. Разделение свойств

Каждое свойство ДОЛЖНО отделяться от других свойств, констант и методов одной пустой строкой.
Если свойство объявляется, как первый элемент класса - пустая строка перед ним НЕДОПУСТИМА.
Если свойство объявляется, как последний элемент класса - пустая строка после него НЕДОПУСТИМА.

> Пример:
>
> ```php
> // Правильно
> /** @var string[] */
> private $userNames;
>
> /** @var int[] */
> private $userIds;
> ```
>
> ```php
> // Не правильно
> /** @var string[] */
> private $userNames;
> /** @var int[] */
> private $userIds;
> ```
>
> ```php
> // Правильно
> {
>     /** @var string[] */
>     private $userNames;
> ```
>
> ```php
> // Не правильно
> {
>
>     /** @var string[] */
>     private $userNames;
> ```
>
> ```php
> // Правильно
>     /** @var string[] */
>     private $userNames;
> }
> ```
>
> ```php
> // Не правильно
>     /** @var string[] */
>     private $userNames;
>
> }
> ```

### 3.4. Модификаторы доступа для свойств

Для модификаторов доступа к свойствам ДОЛЖНЫ выполняться следующие правила:

* `private` - СЛЕДУЕТ использовать по умолчанию;
* `protected` - СЛЕДУЕТ использоваться только для случаев доступа из дочерних классов;
* `public` - использование НЕДОПУСТИМО;
* `static` - использование НЕДОПУСТИМО.

### 3.5. Именование методов

Названия методов ДОЛЖНЫ описывать предназначение их использования внешним кодом, а не детали реализации.

> Пример:
>
> ```php
> // Правильно
> public function findUserById(int $id): ?User
> ```
>
> ```php
> // Не правильно
> public function find(int $id): ?User
> ```

### 3.6. Разделение методов

Каждый метод ДОЛЖЕН отделяться от других методов, свойств и констант одной пустой строкой.
Если метод объявляется, как первый элемент класса - пустая строка перед ним НЕДОПУСТИМА.
Если метод объявляется, как последний элемент класса - пустая строка после него НЕДОПУСТИМА.

> Пример:
>
> ```php
> // Правильно
> public function findUserById(int $id): ?User
> // ...
> }
>
> public function findUserByName(string $name): ?User
> // ...
> }
> ```
>
> ```php
> // Не правильно
> public function findUserById(int $id): ?User
> // ...
> }
> public function findUserByName(string $name): ?User
> // ...
> }
> ```
>
> ```php
> // Правильно
> {
>     public function findUserById(int $id): ?User
> ```
>
> ```php
> // Не правильно
> {
>
>     public function findUserById(int $id): ?User
> ```
>
> ```php
> // Правильно
>     public function findUserById(int $id): ?User
> }
> ```
>
> ```php
> // Не правильно
>     public function findUserById(int $id): ?User
>
> }
> ```

### 3.7. Модификаторы доступа для методов

Для модификаторов доступа к свойствам ДОЛЖНЫ выполняться следующие правила:

* `private` - СЛЕДУЕТ использовать для методов, предназначенных для использования внутри класса;
* `protected` - СЛЕДУЕТ использоваться только для случаев доступа из дочерних классов;
* `public` - СЛЕДУЕТ использовать для методов, которые предназначены для использования из вне;
* `static` - использование НЕДОПУСТИМО.

### 3.8. Порядок аргументов в методе

Аргументы метода ДОЛЖНЫ объявляться в следующей последовательности:

1. Типизированные аргументы.
2. Nullable-аргументы.
3. Опциональные аргументы.
4. Аргумент с `...`.

### 3.9. Массив в виде аргумента

Для методов, содержащих один и более аргументов с типом массив - РЕКОМЕНДУЕТСЯ указывать хотя бы один такой аргумент
с помощью оператора `...`.

> Пример:
>
> ```php
> // Правильно
> public function concatStrings(string ...$parts): string
> ```
>
> ```php
> // Не правильно
> /**
>  * @param string $parts
>  */
> public function concatStrings(array $parts): string
> ```

## 4. Безопасность

### 4.1. Неявные приведения типов

Неявное приведение типов НЕДОПУСТИМО.

> Неявное приведение типов - один из наиболее распространенных источников ошибок.
> Проблемы, возникающие при неявном приведении типов сложно отслеживать,
> так же они могут приводить к не предсказуемым последствиям.
>
> Пример:
>
> ```php
> echo 5 + '5abc5';
> // 10
> ```

### 4.2. Сравнения с преобразованием типов

Сравнения с преобразованием типов `==` и `!=` НЕДОПУСТИМЫ.
Вместо этого НЕОБХОДИМО использовать тождественные сравнения: `===` и `!==`.  

> Проблемы тут те же, что и при неявном приведении типов.
>
> Пример:
>
> ```php
> if ('abc' == 0) {
>     echo 'wat';
> }
> 
> // wat
> ```

### 4.3. Инструкция switch

Использовать инструкцию `switch` НЕОБХОДИМО с гарантией корректности типов каждого проверяемого выражения.

> Инструкция `switch` при выполнении проверок `case` использует сравнения с приведением типов.
> Это может привести к тем же проблемам, что и неявное приведение типов.
>
> Пример:
>
> ```php
> switch ('abc') {
>     case 0:
>         echo 'wat';
>         break;
> }
> 
> // wat
> ```

### 4.4. Присвоения в условных операциях

Присвоение в условиях инструкций `if`, `while`, `do-while` НЕДОПУСТИМО.

> В большом количестве учебной литературы используются конструкции вида `while ($row = ...)` или `if ($row = ...)`.
> Выражения в скобках неявно приводятся к `bool`, что может привести к неожиданным последствиям.
>
> Пример:
>
> ```php
> $rows = [0, null, ''];
> 
> while ($row = next($rows)) {
>     printf("\$row = %s\n", var_dump($row, true));
> }
> 
> // Ничего не выведет
> ```

### 4.5. Ошибки

Создание ошибок с помощью `trigger_error` НЕДОПУСТИМО, вместо этого ДОЛЖНЫ использоваться исключения.

> Ошибки могут быть перехвачены только глобально, с помощью `set_error_handler`.
> Это значит, что контекст выполнения будет потерян.
> Так же ошибки не содержат stack trace, в отличии от исключений. 

### 4.6. Оператор управления ошибками @

Оператор `@` ДОЛЖЕН быть использован для выражений, которые могут бросить ошибку,
для остальных ситуаций его использование НЕДОПУСТИМО.
В случае подавления ошибки ДОЛЖНО быть брошено исключение с описанием причин возникновения ошибки.

> Пример:
> 
> ```php
> // Без @ тут будет Warning: fopen(path/to/not/exists/file): failed to open stream: No such file or directory
> $file = @fopen('path/to/not/exists/file', 'r');
> 
> if ($file === false) {
>     throw new \RuntimeException('Could not open file: "path/to/not/exists/file"');
> }
> ```

### 4.7. goto

Использование инструкции `goto` НЕДОПУСТИМО.

> Оператор `goto` используется для перехода в другую часть программы, чем усложняет чтение и понимание кода.

### 4.8. eval

Использование инструкции `eval` НЕДОПУСТИМО.

> Для безопасного выполнения `eval` необходимо выполнить очень детальный анализ кода, который будет выполняться.
> Сложность требуемых проверок растет экспоненциально с операциями, ожидаемыми для выполнения в `eval`.

### 4.9. Глобальные переменные и global

Использование инструкции `global` НЕДОПУСТИМО.

> Глобальные переменные являются неявными аргументами функции, или метода, не гарантирующими ни тип, ни значение,
> ни даже своего существования.

### 4.10. Суперглобальные переменные

Использование суперглобальных переменных ДОЛЖНО быть сведено к минимуму.
Данные из суперглобальных переменных РЕКОМЕНДУЕТСЯ получать на этапе инициализации.

### 4.11. Динамическая подстановка имен

Динамическая подстановка имен переменных, свойств, функций и методов НЕДОПУСТИМА.

> Динамическая подстановка имен сильно усложняет чтение и отладку кода потому, что конечные имена определяются только
> в рантайме.

> Пример:
>
> ```php
> // Не правильно
> $this->{$methodName}($argument);
> ```

### 4.12. Магические методы

Использование следующих магических методов НЕДОПУСТИМО:

* `__call`
* `__callStatic`
* `__get`
* `__set`

> Данные методы усложняют чтение и понимание кода, как следствие его поддержку.

### 4.13. Валидация аргументов

Каждый аргумент метода (функции) ДОЛЖЕН быть проверен на корректность типа, в случае проксирования этого значения в
вызываемые методы (функции), на корректность типа и граничные значения, в случае обработки. Если аргумент не валиден -
штатное выполнение метода (функции), или метода невозможно, по этой причине ДОЛЖНО быть брошено исключение.

## 5. Тестирование

### 5.1. Покрытие кода

Каждый метод (функция) ДОЛЖНЫ быть покрыты тестами для всех возможных вариантов выполнения метода (функции).

> Пример:
>
> ```php
> // Для данного метода ДОЛЖНО быть 3 теста.
> // 1. Число $number кратно $divider, что бы проверить корректность преобразование типа. Например `divide(4, 2);`
> // 2. Число $number не кратно $divider. Например `divide(1, 2);`
> // 3. Число $number не кратно $divider. Например `divide(3, 0);`
> public function divide(int $number, int $divider): float
> {
>     if ($divider === 0) {
>         throw new \DomainException('Argument $divider must be not zero');
>     }
> 
>     return (float) $number / $divider;
> }
> ```

### 5.2. Стратегия тестирования

Код ТРЕБУЕТСЯ покрывать, согласно "белому ящику". В случае чрезмерной сложности использования "белого ящика" СЛЕДУЕТ
использовать стратегию "черного ящика". 

### 5.3. Именование тест методов

Тестовый метод ДОЛЖЕН начинаться с префикса `test`, далее указывается название тестируемого метода в `UpperCamelCase`.
Тест без дополнительных аспектов в названии ДОЛЖЕН считаться позитивным.
Для описания дополнительных аспектов в названии тестового метода СЛЕДУЕТ использовать префиксы `With` и `Without`.
Множество дополнительных аспектов разделяется с помощью строки `And`.

> Пример:
>
> ```php
> public function testLogMessage(): void
> // ...
> public function testLogMessageWithEmptyMessage(): void
> // ...
> public function testLogMessageWithEmptyMessageAndEmtyContext(): void
> // ...
> public function testLogMessageWithInvalidContext(): void
> ```

### 5.4. Разделение тест методов

Каждый тест метод ДОЛЖЕН быть полностью независим от других тест методов.
Каждый тест метод ДОЛЖЕН проверять конкретное поведение тестируемого метода (функции), тест методы, которые проверяют
несколько аспектов поведения НЕДОПУСТИМЫ.

> Принцип DRY для тестов не применяется, что бы минимизировать ложно позитивные и ложно негативные результаты.

### 5.3. Структура теста

Каждый тест ТРЕБУЕТСЯ оформлять согласно структуре, описанной ниже (каждый блок отделяется от остальных пустой строкой).

1. Переменные, используемые в тесте.
2. Mock-объекты конструктора тестируемого класса.
3. Mock-объекты аргументов тестируемого метода.
4. Создание тестируемого объект.
5. Инкременты вызовов mock-объектов.
6. Поведение методов mock-объектов согласно порядку их вызова.
7. Вызов тестируемого метода.
8. Проверка результатов.

ДОПУСКАЕТСЯ отклонение от данной структуры, в случае, если полное следование ей невозможно. Например, когда значение
переменной [1] определяется только после вызова конструктора тестируемого класса [4].

### 5.4. Переменные, используемые в тесте

Переменные, используемые в тесте ДОЛЖНЫ следовать следующим правилам.

1. НЕДОПУСТИМО использовать свойства тест классов.
2. Значения, которые будут использоваться отдельно ДОЛЖНЫ быть вынесены в отдельные переменные.
3. Значения для переменных ТРЕБУЕТСЯ указывать явно.
4. Значения для переменных НЕ ДОЛЖНЫ зависеть от времени, кроме ситуаций, когда тестируемый метод зависит от текущего
времени.

### 5.5. Mock-объекты

Mock-объект ДОЛЖЕН быть объявлен, согласно следующим правилам.

1. Переменную, содержащая mock-объект СЛЕДУЕТ называть согласно названию аргумента метода (функции), где будет
использоваться данный объект.
2. Mock-объект ДОЛЖЕН быть помечен строчным docblock, содержащими класс объекта, для которого создается mock и
mock-интерфейс.
3. Mock-объект ДОЛЖЕН присваиваться переменной тестового метода.

### 5.6. Тестируемый объект

Тестируемый объект ТРЕБУЕТСЯ создавать с помощью оператора `new`. В случае невозможности, или чрезмерной сложности теста
ДОПУСКАЕТСЯ использовать mock от тестируемого класса.
Название для объекта СЛЕДУЕТ использовать то же, что и название тестируемого класса, в lowerCamelCase.

### 5.7. Инкременты вызовов mock-объектов

Инкременты вызовов mock-объектов - это переменные типа `int`, со значением 0.
Названия для этих переменных ДОЛЖНЫ повторять названия mock-объектов, которым они соответствуют с суффиксом `Increment`.
Инкременты ДОЛЖНЫ использоваться, когда необходимо описать последовательность вызовов методов mock-объекта.

### 5.7. Поведение методов mock-объектов (PHPUnit)

###### 5.7.1. expects

Метод`expects` ДОЛЖЕН вызываться с параметрами: 

* `$this->once()`
* `$this->never()`
* `$this->at($mockObjectIncrement++)` в этом случае использование `once`, `never` для других методов того же
mock-объекта НЕДОПУСТИМО.

В случае, когда метод не должен вызываться НЕОБХОДИМО использовать метод `never`.

###### 5.7.2. method

ДОЛЖЕН указываться после `expects` и вызываться со строкой, содержащей название метода.

###### 5.7.2. with

ДОЛЖЕН содержать проверки для каждого аргумента. Если аргументы отсутсвуют - метод `with` НЕ ДОЛЖЕН вызываться.
В случае невозможности проверки аргумента с помощью простой передачи - ДОЛЖЕН использоваться метод `callback`.

###### 5.7.3. willReturn

ДОЛЖЕН быть указан после вызова `with`, или `method` (если `with` отсутствует).

###### 5.7.4. willReturnSelf

НЕОБХОДИМО использовать в случаях, когда возвращается этот же mock-объект, вместо конструкции `willReturn($mockObject)`.

###### 5.7.5. willThrowException

НЕОБХОДИМО использовать в случаях, когда метод должен бросить исключение.

### 5.8. Проверка результатов

Проверку результатов НЕОБХОДИМО выполнять на тождество, т.е. и на тип и на значение.
Числа с плавающей точкой ДОЛЖНЫ проверяться с учетом погрешности.
Значения времени, зависящие от текущего времени ДОЛЖНЫ проверяться с учетом погрешности.

## 6. IDE

Для разработки php проектов РЕКОМЕНДУЕТСЯ использовать [PhpStorm](https://www.jetbrains.com/phpstorm/).

#### TODO
Настройки кодстайла РЕКОМЕНДУЕТСЯ импортировать из файла `phpstorm/codeStyle.xml` текущего репозитория.
Настройки инспекций РЕКОМЕНДУЕТСЯ импортировать из файла `phpstorm/inspections.xml` текущего репозитория.